# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y08gSJBKkK_ghD7iDPfgF0hZqRNVu8mo
"""

# Commented out IPython magic to ensure Python compatibility.

# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

# Constants
e = 1.602e-19  # Charge in C
m = 9.109e-31  # Mass in kg
KE = 20 * e    # Kinetic energy in Joules
v_mag = np.sqrt(2 * KE / m)  # Initial speed

# Initial direction
theta = np.pi / 6
phi = np.pi / 2
v0 = v_mag * np.array([
    np.sin(theta) * np.cos(phi),
    np.sin(theta) * np.sin(phi),
    np.cos(theta)
])

# Fields
Bz = 0.001  # Tesla
E_mag = 350 # V/m
B = np.array([0, 0, Bz])
regions = {
    "Ao": np.array([E_mag, 0, 0]),
    "Bo": np.array([-E_mag, 0, 0]),
    "Co": np.array([E_mag, 0, 0])
}

# Time setup
total_length = 0.3556  # Chamber length in meters (14 inches)
v_z = v_mag * np.cos(theta)
total_time = total_length / v_z  # Total time to traverse chamber
region_time = total_time / 3  # Time per region
dt = 1e-11
steps_per_region = int(region_time / dt)
region_durations = {
    "Ao": steps_per_region,
    "Bo": steps_per_region,
    "Co": steps_per_region
}
total_steps = sum(region_durations.values())

# Boris algorithm
def boris_push(pos, vel, E, B, dt, q, m):
    v_minus = vel + (q * E / m) * (dt / 2)
    t = (q * B / m) * (dt / 2)
    v_prime = v_minus + np.cross(v_minus, t)
    s = 2 * t / (1 + np.dot(t, t))
    v_plus = v_minus + np.cross(v_prime, s)
    v_new = v_plus + (q * E / m) * (dt / 2)
    r_new = pos + v_new * dt
    return r_new, v_new

# Simulation
def simulate_motion(q):
    pos = [np.zeros(3)]
    vel = [v0]
    times = [0]
    region_switch = {
        region: sum(list(region_durations.values())[:i+1])
        for i, region in enumerate(region_durations)
    }

    for step in range(1, total_steps):
        if step <= region_switch["Ao"]:
            E = regions["Ao"]
        elif step <= region_switch["Bo"]:
            E = regions["Bo"]
        else:
            E = regions["Co"]

        r_new, v_new = boris_push(pos[-1], vel[-1], E, B, dt, q, m)
        pos.append(r_new)
        vel.append(v_new)
        times.append(step * dt)

    return np.array(pos), np.array(vel), np.array(times)

# Plot obstacle
def plot_obstacle(ax):
    x = [-0.0127,0.0762]
    y = [-0.0254,0.0254]
    z = [0.1524, 0.2032]
    vertices = [
        [[x[0], y[0], z[0]], [x[1], y[0], z[0]], [x[1], y[1], z[0]], [x[0], y[1], z[0]]],  # Bottom face
        [[x[0], y[0], z[1]], [x[1], y[0], z[1]], [x[1], y[1], z[1]], [x[0], y[1], z[1]]]   # Top face
    ]
    faces = [
        vertices[0],  # Bottom face
        vertices[1],  # Top face
        [vertices[0][0], vertices[1][0], vertices[1][3], vertices[0][3]],  # Side 1
        [vertices[0][1], vertices[1][1], vertices[1][2], vertices[0][2]],  # Side 2
        [vertices[0][0], vertices[1][0], vertices[1][1], vertices[0][1]],  # Side 3
        [vertices[0][3], vertices[1][3], vertices[1][2], vertices[0][2]]   # Side 4
    ]
    # Scale vertices by 100 when plotting to match the trajectory units (cm)
    scaled_faces = [[[vertex[0] * 100, vertex[1] * 100, vertex[2] * 100] for vertex in face] for face in faces]
    ax.add_collection3d(Poly3DCollection(scaled_faces, alpha=0.3, facecolors='red', edgecolors='black'))

# Run simulation for positron and electron
pos_positron, _, times = simulate_motion(q=e)
pos_electron, _, _ = simulate_motion(q=-e)

# Plot x(t), y(t), z(t) for each region
region_times = {
    "Ao": (0, region_durations["Ao"] * dt),
    "Bo": (region_durations["Ao"] * dt, (region_durations["Ao"] + region_durations["Bo"]) * dt),
    "Co": ((region_durations["Ao"] + region_durations["Bo"]) * dt, total_steps * dt)
}

for region in ["Ao", "Bo", "Co"]:
    start_time, end_time = region_times[region]
    mask = (times >= start_time) & (times <= end_time)
    t_region = times[mask]
    pos_p_region = pos_positron[mask]
    pos_e_region = pos_electron[mask]

    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 8), sharex=True)
    ax1.plot(t_region * 1e9, pos_p_region[:, 0] * 300, label='Positron', color='blue')
    ax1.plot(t_region * 1e9, pos_e_region[:, 0] * 300, label='Electron', color='red', linestyle='--')
    ax1.set_ylabel('x (cm)')
    ax1.set_title(f'{region} Region: Position vs Time')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(t_region * 1e9, pos_p_region[:, 1] * 300, label='Positron', color='blue')
    ax2.plot(t_region * 1e9, pos_e_region[:, 1] * 300, label='Electron', color='red', linestyle='--')
    ax2.set_ylabel('y (cm)')
    ax2.legend()
    ax2.grid(True)

    ax3.plot(t_region * 1e9, pos_p_region[:, 2] * 300, label='Positron', color='blue')
    ax3.plot(t_region * 1e9, pos_e_region[:, 2] * 300, label='Electron', color='red', linestyle='--')
    ax3.set_ylabel('z (cm)')
    ax3.set_xlabel('Time (ns)')
    ax3.legend()
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig(f'position_vs_time_{region}.png')
    plt.show()  # Display the plot inline

# Plot 3D trajectory for the whole chamber
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot(pos_positron[:, 0] * 350, pos_positron[:, 1] * 350, pos_positron[:, 2] * 350,
        label='Positron', color='blue')
ax.plot(pos_electron[:, 0] * 350, pos_electron[:, 1] * 350, pos_electron[:, 2] * 350,
        label='Electron', color='red', linestyle='--')
plot_obstacle(ax)
ax.set_xlabel('X (cm)')
ax.set_ylabel('Y (cm)')
ax.set_zlabel('Z (cm)')
ax.set_title('3D Trajectory in Chamber')
ax.set_xlim([-7.62, 7.62])
ax.set_ylim([-7.62, 20.32])  # Ensure obstacle is visible
ax.set_zlim([0, 35.56])
ax.view_init(elev=0, azim= 182)  # Rotate view to show x-z plane
ax.legend()
plt.tight_layout()
plt.savefig('trajectory_chamber.png')
plt.show()  # Display the plot inline